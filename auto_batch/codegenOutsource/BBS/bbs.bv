name := bbs
N := 100
setting := asymmetric

BEGIN :: types
 n := int
 x := list{ZR}
 A := list{G1}
 A_ind := G1
 x_ind := ZR
 r := list{ZR}
 M := str
 g1 := G1
 g2 := G2
 T1 := G1
 T2 := G1  
 T3 := G1
 h := G1
 u := G1 
 v := G1
 w := G2 
 R3 := GT
 sx := ZR
 salpha := ZR
 sbeta := ZR
 sgamma1 := ZR
 sgamma2 := ZR
 c := ZR
END :: types

BEGIN :: func:precheck
input := list{g1, g2, h, u, v, w, c, M, T1, T2, T3, R3, sx, salpha, sbeta, sgamma1, sgamma2} 
 R1ver := (u ^ salpha) * (T1 ^ -c)
 R2ver := (v ^ sbeta) * (T2 ^ -c)
 R4ver := (T1 ^ sx) * (u ^ -sgamma1)
 R5ver := (T2 ^ sx) * (v ^ -sgamma2)

BEGIN :: if 
 if { c != H(concat{M, T1, T2, T3, R1ver, R2ver, R3, R4ver, R5ver}, ZR) }
   output := False  
 else
   output := True
END :: if
END :: func:precheck

BEGIN :: precompute
check := { precheck(g1, g2, h, u, v, w, c, M, T1, T2, T3, R3, sx, salpha, sbeta, sgamma1, sgamma2) }
END :: precompute

constant := list{g1, g2, h, u, v, w}
public := list{h, u, v, w}
signature := list{T1, T2, T3, R3, c, salpha, sbeta, sx, sgamma1, sgamma2}
message := M

# different messages/sigs under a single signer
BEGIN :: count
message_count := N
public_count := one
signature_count := N
END :: count

verify := { ((e(T3, g2)^sx) * ((e(h, w)^(-salpha + -sbeta)) * ((e(h, g2)^(-sgamma1 + -sgamma2)) * ((e(T3, w)^c) * (e(g1, g2)^-c)))))) == R3 }

BEGIN :: func:keygen
input := n
 g1 := random(G1)
 g2 := random(G2)
 h := random(G1)
 xi1 := random(ZR)
 xi2 := random(ZR)
 u := h ^ (1 / xi1)
 v := h ^ (1 / xi2)
 gamma := random(ZR)
 w := g2 ^ gamma
 gpk := list{g1, g2, h, u, v, w}
 gmsk := list{xi1, xi2}
 
BEGIN :: for
for{y := 0, n}
 x#y := random(ZR)
 A#y := g1 ^ (1 / (gamma + x#y))
END :: for

 output := list{gpk, gmsk, A, x}
END :: func:keygen

BEGIN :: func:sign
input := list{gpk, A_ind, x_ind, M}
gpk := expand{g1, g2, h, u, v, w}

 alpha := random(ZR)
 beta := random(ZR)
 T1 := u ^ alpha
 T2 := v ^ beta
 T3 := A_ind * (h ^ (alpha + beta))
 delta1 := x_ind * alpha
 delta2 := x_ind * beta

 r#0 := random(ZR)
 r#1 := random(ZR)
 r#2 := random(ZR)
 r#3 := random(ZR)
 r#4 := random(ZR)
 r#5 := random(ZR)

 R1 := u ^ r#0
 R2 := v ^ r#1
 R3 := (e(T3, g2) ^ r#2) * (e(h, w) ^ (-r#0 - r#1)) * (e(h, g2) ^ (-r#3 - r#4))
 R4 := (T1 ^ r#2) * (u ^ -r#3)
 R5 := (T2 ^ r#2) * (v ^ -r#4)

 c := H(concat{M, T1, T2, T3, R1, R2, R3, R4, R5}, ZR)
 s1 := r#0 + c * alpha
 s2 := r#1 + c * beta
 s3 := r#2 + c * x_ind
 s4 := r#3 + c * delta1
 s5 := r#4 + c * delta2
 sig := list{T1, T2, T3, c, salpha, sbeta, sx, sgamma1, sgamma2}
 output := sig
END :: func:sign

#input := list{gpk, M, sig}
# gpk := expand{g1, g2, h, u, v, w}
# sig := expand{T1, T2, T3, c, salpha, sbeta, sx, sgamma1, sgamma2}

BEGIN :: func:verify
input := list{g1, g2, h, u, v, w, c, M, T1, T2, T3, R3, sx, salpha, sbeta, sgamma1, sgamma2}

BEGIN :: if
 if { precheck(g1, g2, h, u, v, w, c, M, T1, T2, T3, R3, sx, salpha, sbeta, sgamma1, sgamma2) == False }
    output := False
END :: if

BEGIN :: if
 if { ((e(T3, g2) ^ sx) * (e(h, w) ^ (-salpha - sbeta)) * (e(h, g2) ^ (-sgamma1 - sgamma2)) * ((e(T3, w)^c) * (e(g1, g2) ^ -c))) == R3}
    output := True
 else
    output := False
END :: if
END :: func:verify
