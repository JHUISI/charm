
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>For Cryptographers &#8212; Charm-Crypto 0.50 documentation</title>
    <link rel="stylesheet" href="_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.50',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="For App Developers" href="developers.html" />
    <link rel="prev" title="Android Build" href="mobile.html" /> 
  </head>
  <body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="developers.html" title="For App Developers"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="mobile.html" title="Android Build"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Charm-Crypto 0.50 documentation</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="for-cryptographers">
<h1>For Cryptographers<a class="headerlink" href="#for-cryptographers" title="Permalink to this headline">¶</a></h1>
<p>Interested in implementing your cryptographic scheme in Charm? Here’s a guide to navigate our framework to implement your cryptosystem:</p>
<div class="section" id="group-abstractions">
<h2>Group Abstractions<a class="headerlink" href="#group-abstractions" title="Permalink to this headline">¶</a></h2>
<p>The first stage of new scheme development is selecting the appropriate group to instantiate a scheme. Modern cryptographic algorithms are typically implemented on top of mathematical groups based on certain hardness assumptions (e.g., Diffie-Hellman). We provide the same building blocks to facilitate development in this way of thinking:</p>
<p>At the moment, there are three cryptographic settings covered by Charm (will be expanded in the future): <code class="docutils literal"><span class="pre">integergroups</span></code>, <code class="docutils literal"><span class="pre">ecgroups</span></code>, and <code class="docutils literal"><span class="pre">pairinggroups</span></code>.
To initialize a group in the elliptic curve (EC) setting, refer to the <code class="docutils literal"><span class="pre">toolbox.eccurve</span></code> for the full set of identifiers and supported NIST approved curves (e.g., <code class="docutils literal"><span class="pre">prime192v1</span></code>). For EC with billinear maps (or pairings), we provide a set of identifiers for both symmetric and asymmetric type of curves. For example, the <code class="docutils literal"><span class="pre">'SS512'</span></code> represents a symmetric curve with a 512-bit base field and <code class="docutils literal"><span class="pre">'MNT159'</span></code> represents an asymmetric curve with 159-bit base field. Note that these curves are of prime order.
Finally, for integer groups, typically defining large primes <code class="docutils literal"><span class="pre">p</span></code> and <code class="docutils literal"><span class="pre">q</span></code> is enough to generate an RSA group. For schnorr groups, these group parameters may take some time to generate because they require safe primes (e.g., <code class="docutils literal"><span class="pre">p</span> <span class="pre">=</span> <span class="pre">2q</span> <span class="pre">+</span> <span class="pre">1</span></code>). Here are detailed examples below for integer and pairing groups (see above for EC group initialization):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">charm.toolbox.integergroup</span> <span class="k">import</span> <span class="n">IntegerGroup</span>

<span class="n">group1</span> <span class="o">=</span> <span class="n">IntegerGroup</span><span class="p">()</span>
<span class="n">group1</span><span class="o">.</span><span class="n">paramgen</span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span>

<span class="n">g</span> <span class="o">=</span> <span class="n">group1</span><span class="o">.</span><span class="n">randomGen</span><span class="p">()</span>

<span class="kn">from</span> <span class="nn">charm.toolbox.pairinggroup</span> <span class="k">import</span> <span class="n">PairingGroup</span><span class="p">,</span><span class="n">ZR</span><span class="p">,</span><span class="n">G1</span><span class="p">,</span><span class="n">G2</span><span class="p">,</span><span class="n">GT</span><span class="p">,</span><span class="n">pair</span>

<span class="n">group2</span> <span class="o">=</span> <span class="n">PairingGroup</span><span class="p">(</span><span class="s1">&#39;SS512&#39;</span><span class="p">)</span>

<span class="n">g</span> <span class="o">=</span> <span class="n">group2</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">G1</span><span class="p">)</span>
<span class="n">g</span> <span class="o">=</span> <span class="n">group2</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">G2</span><span class="p">)</span>
<span class="o">...</span>
</pre></div>
</div>
</div>
<div class="section" id="implement-a-scheme">
<h2>Implement a Scheme<a class="headerlink" href="#implement-a-scheme" title="Permalink to this headline">¶</a></h2>
<p>As an example, we show the implementation of a public-key encryption scheme due to Cramer-Shoup 1998 <a class="reference external" href="http://knot.kaist.ac.kr/seminar/archive/46/46.pdf">http://knot.kaist.ac.kr/seminar/archive/46/46.pdf</a>, which is provably secure against adaptive chosen ciphertext attacks.</p>
<p>Typical implementations follow an object-oriented model such that an implementation of a cryptosystem can be easily reused or extended for other purposes. To this end, we provide several base classes with standard interfaces for a variety of cryptographic primitives such as <code class="docutils literal"><span class="pre">PKEnc</span></code> or public-key encryption, <code class="docutils literal"><span class="pre">PKSig</span></code> or public-key signatures, <code class="docutils literal"><span class="pre">ABEnc</span></code> or attribute-based encryption and many more. So, the following describes the python code that implements the Cramer-Shoup PKEnc scheme in Charm:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">charm.toolbox.ecgroup</span> <span class="k">import</span> <span class="n">ECGroup</span>

<span class="k">class</span> <span class="nc">CS98</span><span class="p">(</span><span class="n">PKEnc</span><span class="p">):</span>
     <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">curve</span><span class="p">):</span>
         <span class="n">PKEnc</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
         <span class="k">global</span> <span class="n">group</span>
         <span class="n">group</span> <span class="o">=</span> <span class="n">ECGroup</span><span class="p">(</span><span class="n">curve</span><span class="p">)</span>
</pre></div>
</div>
<p>Before we get started, it is important to understand that in our toolbox each cryptographic setting has a corresponding group abstraction such as elliptic curve group or <code class="docutils literal"><span class="pre">ECGroup</span></code>, pairing group or <code class="docutils literal"><span class="pre">PairingGroup</span></code>, and integer groups or <code class="docutils literal"><span class="pre">IntegerGroup</span></code>. These abstractions provide a convenient and simple interface for selecting group parameters, performing group operations, and even benchmarking. See the <a class="reference internal" href="toolbox.html#toolbox"><span class="std std-ref">Toolbox Classes</span></a> documentation for more details.</p>
<p>Thus, at the beginning of the scheme, you must import the corresponding group setting in which the cryptographic scheme will be implemented</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">charm.toolbox.ecgroup</span> <span class="k">import</span> <span class="n">ECGroup</span>
</pre></div>
</div>
<p>Next, let’s explain what goes on during class initialization. During <code class="docutils literal"><span class="pre">__init__</span></code>, we define the basic security properties of the <code class="docutils literal"><span class="pre">PKEnc</span></code> scheme and in this case, accept as input a NIST standard elliptic curve identifier. The group object can either be defined globally or defined as a class member. The idea is that any routine within this scheme will have access to the group object to perform any operation. In our example, we define group as a global variable. Alternatively, define group as <code class="docutils literal"><span class="pre">self.group</span> <span class="pre">=</span> <span class="pre">ECGroup(curve)</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Also, the <code class="docutils literal"><span class="pre">init</span></code> routine arguments can vary depending on the scheme and group setting. What is shown above is only an example and see other schemes we have implemented for full list of possibilities.</p>
</div>
<p>Let’s take a look at the first algorithm in the paper, <code class="docutils literal"><span class="pre">keygen</span></code>. Keygen only accepts a security parameter, generates the public and private keys and returns them the user. The paper description is as follows:</p>
<div class="math" id="equation-keygen1">
<p><span class="eqno">(1)</span><img src="_images/math/68daa260f70d2016741ef92b11646b04dd8941d4.png" alt="g_1, g_2 \in G"/></p>
</div><div class="math" id="equation-keygen2">
<p><span class="eqno">(2)</span><img src="_images/math/8c0ba324c678fec876e3cbfd346b70c8f34a27d8.png" alt="x_1, x_2, y_1, y_2, z \in Z_q"/></p>
</div><div class="math" id="equation-keygen3">
<p><span class="eqno">(3)</span><img src="_images/math/5e58859d062207bb2baa2e055fbc8036f21640c9.png" alt="c = {g_1}^{x_1} \cdot {g_2}^{x_2}, d = {g_1}^{y_1} \cdot {g_2}^{y_2}, h = {g_1}^z"/></p>
</div><div class="math" id="equation-pk">
<p><span class="eqno">(4)</span><img src="_images/math/3bb00e1a6e63a3a2526f39e250a94b8bdfc613d4.png" alt="pk = (g_1, g_2, c, d, h, H)"/></p>
</div><div class="math" id="equation-sk">
<p><span class="eqno">(5)</span><img src="_images/math/aac19f55f081ce378d8c99eda11ad5a54717c054.png" alt="sk = (x_1, x_2, y_1, y_2, z)"/></p>
</div><p>Group elements <a class="reference internal" href="#equation-keygen1">(1)</a> and <a class="reference internal" href="#equation-keygen2">(2)</a> are selected at random. Next, the group elements <a class="reference internal" href="#equation-keygen3">(3)</a> are computed. Then, select a hash function H from the family of universal one-way hash functions. The public key is defined by <a class="reference internal" href="#equation-pk">(4)</a> and the private key is defined by <a class="reference internal" href="#equation-sk">(5)</a>. Below is the Charm <code class="docutils literal"><span class="pre">keygen</span></code> function defined in the <code class="docutils literal"><span class="pre">CS98</span></code> class:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">keygen</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">secparam</span><span class="p">):</span>
    <span class="n">g1</span><span class="p">,</span> <span class="n">g2</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">G</span><span class="p">),</span> <span class="n">group</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
    <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">y2</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">ZR</span><span class="p">),</span> <span class="n">group</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">ZR</span><span class="p">),</span> <span class="n">group</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">ZR</span><span class="p">),</span> <span class="n">group</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">ZR</span><span class="p">),</span> <span class="n">group</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">ZR</span><span class="p">)</span>
    <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="n">g1</span> <span class="o">**</span> <span class="n">x1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">g2</span> <span class="o">**</span> <span class="n">x2</span><span class="p">)</span>
    <span class="n">d</span> <span class="o">=</span> <span class="p">(</span><span class="n">g1</span> <span class="o">**</span> <span class="n">y1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">g2</span> <span class="o">**</span> <span class="n">y2</span><span class="p">)</span>
    <span class="n">h</span> <span class="o">=</span> <span class="p">(</span><span class="n">g1</span> <span class="o">**</span> <span class="n">z</span><span class="p">)</span>

    <span class="n">pk</span> <span class="o">=</span> <span class="p">{</span> <span class="s1">&#39;g1&#39;</span> <span class="p">:</span> <span class="n">g1</span><span class="p">,</span> <span class="s1">&#39;g2&#39;</span> <span class="p">:</span> <span class="n">g2</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span> <span class="p">:</span> <span class="n">c</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span> <span class="p">:</span> <span class="n">d</span><span class="p">,</span> <span class="s1">&#39;h&#39;</span> <span class="p">:</span> <span class="n">h</span><span class="p">,</span> <span class="s1">&#39;H&#39;</span> <span class="p">:</span> <span class="n">group</span><span class="o">.</span><span class="n">hash</span> <span class="p">}</span>
    <span class="n">sk</span> <span class="o">=</span> <span class="p">{</span> <span class="s1">&#39;x1&#39;</span> <span class="p">:</span> <span class="n">x1</span><span class="p">,</span> <span class="s1">&#39;x2&#39;</span> <span class="p">:</span> <span class="n">x2</span><span class="p">,</span> <span class="s1">&#39;y1&#39;</span> <span class="p">:</span> <span class="n">y1</span><span class="p">,</span> <span class="s1">&#39;y2&#39;</span> <span class="p">:</span> <span class="n">y2</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span> <span class="p">:</span> <span class="n">z</span> <span class="p">}</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">pk</span><span class="p">,</span> <span class="n">sk</span><span class="p">)</span>
</pre></div>
</div>
<div class="math" id="equation-prelim">
<p><span class="eqno">(6)</span><img src="_images/math/5d3ec2ecd23d8d62a2bab4a65fc10793d03c89a1.png" alt="m \in G, r \in Z_q"/></p>
</div><div class="math" id="equation-encrypt">
<p><span class="eqno">(7)</span><img src="_images/math/0548bb475904a37e3ff97076aae0ced8e26778d8.png" alt="u_1 = {g_1}^r, u_2 = {g_2}^r, e = h^r\cdot m, \alpha = H(u_1, u_2, e), v = c^r\cdot d^{r\alpha}"/></p>
</div><div class="math" id="equation-ciphertext">
<p><span class="eqno">(8)</span><img src="_images/math/56b20563e2ee7a969c53e42c7733643d20ee7e73.png" alt="(u_1, u_2, e, v)"/></p>
</div><p>Let’s take a look at the encrypt routine as described in the paper. Given a message in G, the encryption algorithm first selects a random integer r <a class="reference internal" href="#equation-prelim">(6)</a>, then computes <a class="reference internal" href="#equation-encrypt">(7)</a> and returns the ciphertext as <a class="reference internal" href="#equation-ciphertext">(8)</a>. The <code class="docutils literal"><span class="pre">encrypt</span></code> algorithm defined in Charm:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">encrypt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pk</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
    <span class="n">r</span>   <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">ZR</span><span class="p">)</span>
    <span class="n">u1</span>  <span class="o">=</span> <span class="n">pk</span><span class="p">[</span><span class="s1">&#39;g1&#39;</span><span class="p">]</span> <span class="o">**</span> <span class="n">r</span>
    <span class="n">u2</span>  <span class="o">=</span> <span class="n">pk</span><span class="p">[</span><span class="s1">&#39;g2&#39;</span><span class="p">]</span> <span class="o">**</span> <span class="n">r</span>
    <span class="n">e</span>   <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">pk</span><span class="p">[</span><span class="s1">&#39;h&#39;</span><span class="p">]</span> <span class="o">**</span> <span class="n">r</span><span class="p">)</span>
    <span class="n">alpha</span> <span class="o">=</span> <span class="n">pk</span><span class="p">[</span><span class="s1">&#39;H&#39;</span><span class="p">](</span><span class="n">u1</span><span class="p">,</span> <span class="n">u2</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
    <span class="n">v</span>   <span class="o">=</span> <span class="p">(</span><span class="n">pk</span><span class="p">[</span><span class="s1">&#39;c&#39;</span><span class="p">]</span> <span class="o">**</span> <span class="n">r</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">pk</span><span class="p">[</span><span class="s1">&#39;d&#39;</span><span class="p">]</span> <span class="o">**</span> <span class="p">(</span><span class="n">r</span> <span class="o">*</span> <span class="n">alpha</span><span class="p">))</span>

    <span class="k">return</span> <span class="p">{</span> <span class="s1">&#39;u1&#39;</span> <span class="p">:</span> <span class="n">u1</span><span class="p">,</span> <span class="s1">&#39;u2&#39;</span> <span class="p">:</span> <span class="n">u2</span><span class="p">,</span> <span class="s1">&#39;e&#39;</span> <span class="p">:</span> <span class="n">e</span><span class="p">,</span> <span class="s1">&#39;v&#39;</span> <span class="p">:</span> <span class="n">v</span> <span class="p">}</span>
</pre></div>
</div>
<div class="math" id="equation-decrypt1">
<p><span class="eqno">(9)</span><img src="_images/math/1ee94ac15a30ab8b09405e6985b249f90c8f9289.png" alt="\alpha = H(u_1, u_2, e)"/></p>
</div><div class="math" id="equation-decrypt2">
<p><span class="eqno">(10)</span><img src="_images/math/60a5f522f97c067ae90bd994d7dbc83b1bb22a8d.png" alt="{u_1}^{x_1 + y_1\alpha} {u_2}^{x_2 + y_2\alpha} = v"/></p>
</div><div class="math" id="equation-decrypt3">
<p><span class="eqno">(11)</span><img src="_images/math/a8e8bc237e64e5df015ed5cdba8ec65342271279.png" alt="m = e / {u_1}^z"/></p>
</div><p>Finally, the decryption routine as described in the paper. Given a ciphertext, the decryption algorithm runs as follows and first computes <a class="reference internal" href="#equation-decrypt1">(9)</a>, and tests if <a class="reference internal" href="#equation-decrypt2">(10)</a> condition holds, and if so outputs <a class="reference internal" href="#equation-decrypt3">(11)</a> otherwise “reject”. The <code class="docutils literal"><span class="pre">decrypt</span></code> algorithm defined in Charm:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">decrypt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pk</span><span class="p">,</span> <span class="n">sk</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
    <span class="n">alpha</span> <span class="o">=</span> <span class="n">pk</span><span class="p">[</span><span class="s1">&#39;H&#39;</span><span class="p">](</span><span class="n">c</span><span class="p">[</span><span class="s1">&#39;u1&#39;</span><span class="p">],</span> <span class="n">c</span><span class="p">[</span><span class="s1">&#39;u2&#39;</span><span class="p">],</span> <span class="n">c</span><span class="p">[</span><span class="s1">&#39;e&#39;</span><span class="p">])</span>

    <span class="n">v_prime</span> <span class="o">=</span> <span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="s1">&#39;u1&#39;</span><span class="p">]</span> <span class="o">**</span> <span class="p">(</span><span class="n">sk</span><span class="p">[</span><span class="s1">&#39;x1&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">sk</span><span class="p">[</span><span class="s1">&#39;y1&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">alpha</span><span class="p">)))</span> <span class="o">*</span> <span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="s1">&#39;u2&#39;</span><span class="p">]</span> <span class="o">**</span> <span class="p">(</span><span class="n">sk</span><span class="p">[</span><span class="s1">&#39;x2&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">sk</span><span class="p">[</span><span class="s1">&#39;y2&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">alpha</span><span class="p">)))</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="s1">&#39;v&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="n">v_prime</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;reject&#39;</span>
    <span class="k">return</span> <span class="n">group</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="s1">&#39;e&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="s1">&#39;u1&#39;</span><span class="p">]</span> <span class="o">**</span> <span class="n">sk</span><span class="p">[</span><span class="s1">&#39;z&#39;</span><span class="p">]))</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Since the scheme defines messages as a group element, it is important to use the encode/decode methods to convert the message string into a member of the group, <code class="docutils literal"><span class="pre">G</span></code>. This encoding function makes cryptographic schemes practical for handling real messages. However, the pairing group does not currently implement such routines for encoding/decoding messages as group elements. This is on purpose given the difficulty and risks associated with implementing such encoding algorithms in pairing groups. Other techniques are used for pairings to provide the ability to convert from/to different message spaces.</p>
</div>
<p>For more examples, see the <code class="docutils literal"><span class="pre">schemes</span></code> package that is included in each Charm release.</p>
</div>
<div class="section" id="reusable-tools">
<h2>Reusable Tools<a class="headerlink" href="#reusable-tools" title="Permalink to this headline">¶</a></h2>
<p>Perhaps, you are developing a new scheme that relies on existing building blocks such as block ciphers, hash functions, secret sharing and etc – do not reinvent the wheel! Charm was designed with reusability in mind and to aid cryptographers in easily composing schemes based on existing constructions. Charm has a growing toolbox of reusable components that might simplify your scheme development. If the component you are looking for does not exist in Charm, then once you implement it consider contributing it back to the project for others to leverage. The end goal is to come up with a comprehensive toolbox that all can reuse. See the <a class="reference internal" href="toolbox.html#toolbox"><span class="std std-ref">Toolbox Classes</span></a> section for a detailed list.</p>
</div>
<div class="section" id="testing-benchmarking">
<h2>Testing &amp; Benchmarking<a class="headerlink" href="#testing-benchmarking" title="Permalink to this headline">¶</a></h2>
<p>Once you have implemented your scheme, you might be interested in testing correctness and measuring its efficiency. There are two possible approaches: either define a test routine that executes the algorithms in your scheme via test vectors if they exist and/or embedding the test routine as a docstring in your scheme’s class definition. Docstrings are tests that can be executed directly as follows: <code class="docutils literal"><span class="pre">python</span> <span class="pre">-m</span> <span class="pre">doctest</span> <span class="pre">myScheme.py</span></code>. See examples in the <code class="docutils literal"><span class="pre">schemes</span></code> package.</p>
<p>There are several benchmark flags you should be aware of such as: <code class="docutils literal"><span class="pre">RealTime</span></code>, <code class="docutils literal"><span class="pre">CpuTime</span></code>, <code class="docutils literal"><span class="pre">Add</span></code>, <code class="docutils literal"><span class="pre">Sub</span></code>, <code class="docutils literal"><span class="pre">Mul</span></code>, <code class="docutils literal"><span class="pre">Div</span></code>, and <code class="docutils literal"><span class="pre">Exp</span></code>. Here is an example to demonstrate use of the Charm benchmark interface for the EC setting:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">charm.toolbox.ecgroup</span> <span class="k">import</span> <span class="n">ECGroup</span><span class="p">,</span><span class="n">ZR</span><span class="p">,</span><span class="n">G</span>
<span class="kn">from</span> <span class="nn">charm.toolbox.eccurve</span> <span class="k">import</span> <span class="n">prime192v1</span>

<span class="n">trials</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">group</span> <span class="o">=</span> <span class="n">ECGroup</span><span class="p">(</span><span class="n">prime192v1</span><span class="p">)</span>
<span class="n">g</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="n">h</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="n">i</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>

<span class="k">assert</span> <span class="n">group</span><span class="o">.</span><span class="n">InitBenchmark</span><span class="p">(),</span> <span class="s2">&quot;failed to initialize benchmark&quot;</span>
<span class="n">group</span><span class="o">.</span><span class="n">StartBenchmark</span><span class="p">([</span><span class="s2">&quot;Mul&quot;</span><span class="p">,</span> <span class="s2">&quot;Div&quot;</span><span class="p">,</span> <span class="s2">&quot;Exp&quot;</span><span class="p">,</span> <span class="s2">&quot;Granular&quot;</span><span class="p">])</span>
<span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">trials</span><span class="p">):</span>
    <span class="n">j</span> <span class="o">=</span> <span class="n">g</span> <span class="o">*</span> <span class="n">h</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">h</span> <span class="o">**</span> <span class="n">group</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">ZR</span><span class="p">)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="n">j</span> <span class="o">**</span> <span class="n">group</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">ZR</span><span class="p">))</span> <span class="o">/</span> <span class="n">k</span>
<span class="n">group</span><span class="o">.</span><span class="n">EndBenchmark</span><span class="p">()</span>

<span class="n">msmtDict</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">GetGeneralBenchmarks</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&lt;=== General Benchmarks ===&gt;&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Mul := &quot;</span><span class="p">,</span> <span class="n">msmtDict</span><span class="p">[</span><span class="s2">&quot;Mul&quot;</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Div := &quot;</span><span class="p">,</span> <span class="n">msmtDict</span><span class="p">[</span><span class="s2">&quot;Div&quot;</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Exp := &quot;</span><span class="p">,</span> <span class="n">msmtDict</span><span class="p">[</span><span class="s2">&quot;Exp&quot;</span><span class="p">])</span>
<span class="n">granDict</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">GetGranularBenchmarks</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&lt;=== Granular Benchmarks ===&gt;&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;G mul   := &quot;</span><span class="p">,</span> <span class="n">granDict</span><span class="p">[</span><span class="s2">&quot;Mul&quot;</span><span class="p">][</span><span class="n">G</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;G exp   := &quot;</span><span class="p">,</span> <span class="n">granDict</span><span class="p">[</span><span class="s2">&quot;Exp&quot;</span><span class="p">][</span><span class="n">G</span><span class="p">])</span>
</pre></div>
</div>
<p>Note that thesame benchmark function calls work for the other group settings as well. In particular, the pairing base module also supports the ability to perform benchmarks at a granular level (operation count per group). For this feature, import <code class="docutils literal"><span class="pre">GetGranularBenchmarks</span></code> in addition to <code class="docutils literal"><span class="pre">GetGeneralBenchmarks</span></code> in the <code class="docutils literal"><span class="pre">pairing</span></code> base module. Also, you are required to supply the <code class="docutils literal"><span class="pre">Granular</span></code> benchmark flag when calling <code class="docutils literal"><span class="pre">StartBenchmark</span></code>. Here is an illustrative example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">charm.toolbox.pairinggroup</span> <span class="k">import</span> <span class="n">PairingGroup</span><span class="p">,</span><span class="n">ZR</span><span class="p">,</span><span class="n">G1</span><span class="p">,</span><span class="n">G2</span><span class="p">,</span><span class="n">GT</span><span class="p">,</span><span class="n">pair</span>

<span class="n">trials</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">group</span> <span class="o">=</span> <span class="n">PairingGroup</span><span class="p">(</span><span class="s2">&quot;SS1024&quot;</span><span class="p">)</span>
<span class="n">g</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">G1</span><span class="p">)</span>
<span class="n">h</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">G1</span><span class="p">)</span>
<span class="n">i</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">G2</span><span class="p">)</span>

<span class="k">assert</span> <span class="n">group</span><span class="o">.</span><span class="n">InitBenchmark</span><span class="p">(),</span> <span class="s2">&quot;failed to initialize benchmark&quot;</span>
<span class="n">group</span><span class="o">.</span><span class="n">StartBenchmark</span><span class="p">([</span><span class="s2">&quot;Mul&quot;</span><span class="p">,</span> <span class="s2">&quot;Exp&quot;</span><span class="p">,</span> <span class="s2">&quot;Pair&quot;</span><span class="p">,</span> <span class="s2">&quot;Granular&quot;</span><span class="p">])</span>
<span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">trials</span><span class="p">):</span>
    <span class="n">j</span> <span class="o">=</span> <span class="n">g</span> <span class="o">*</span> <span class="n">h</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">i</span> <span class="o">**</span> <span class="n">group</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">ZR</span><span class="p">)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="n">j</span> <span class="o">**</span> <span class="n">group</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">ZR</span><span class="p">))</span> <span class="o">/</span> <span class="n">h</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">pair</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
<span class="n">group</span><span class="o">.</span><span class="n">EndBenchmark</span><span class="p">()</span>

<span class="n">msmtDict</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">GetGeneralBenchmarks</span><span class="p">()</span>
<span class="n">granDict</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">GetGranularBenchmarks</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&lt;=== General Benchmarks ===&gt;&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Results  := &quot;</span><span class="p">,</span> <span class="n">msmtDict</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&lt;=== Granular Benchmarks ===&gt;&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;G1 mul   := &quot;</span><span class="p">,</span> <span class="n">granDict</span><span class="p">[</span><span class="s2">&quot;Mul&quot;</span><span class="p">][</span><span class="n">G1</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;G2 exp   := &quot;</span><span class="p">,</span> <span class="n">granDict</span><span class="p">[</span><span class="s2">&quot;Exp&quot;</span><span class="p">][</span><span class="n">G2</span><span class="p">])</span>
</pre></div>
</div>
<p>In the integer module, we provide additional support for benchmarking without a group object:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">charm.core.math.integer</span> <span class="k">import</span> <span class="o">*</span>
<span class="n">trials</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">integer</span><span class="p">(</span><span class="mi">1234</span><span class="p">)</span>

<span class="k">assert</span> <span class="n">InitBenchmark</span><span class="p">(),</span> <span class="s2">&quot;failed to initialize benchmark&quot;</span>
<span class="n">StartBenchmark</span><span class="p">([</span><span class="s2">&quot;RealTime&quot;</span><span class="p">,</span> <span class="s2">&quot;Exp&quot;</span><span class="p">,</span> <span class="s2">&quot;Mul&quot;</span><span class="p">])</span>
<span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">trials</span><span class="p">):</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">randomPrime</span><span class="p">(</span><span class="mi">512</span><span class="p">)</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">r</span> <span class="o">*</span> <span class="p">(</span><span class="n">r</span> <span class="o">**</span> <span class="n">a</span><span class="p">)</span>
    <span class="n">j</span> <span class="o">=</span> <span class="n">r</span> <span class="o">*</span> <span class="p">(</span><span class="n">r</span> <span class="o">**</span> <span class="n">a</span><span class="p">)</span>
<span class="n">EndBenchmark</span><span class="p">()</span>

<span class="n">msmtDict1</span> <span class="o">=</span> <span class="n">GetGeneralBenchmarks</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;General Benchmarks: &quot;</span><span class="p">,</span> <span class="n">msmtDict1</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="optimizations">
<h2>Optimizations<a class="headerlink" href="#optimizations" title="Permalink to this headline">¶</a></h2>
<p>For the pairing base module, we now support pre-computation tables for group exponentiation. Note that this speeds up exponentiation signifcantly. To take advantage of this, simply call the <code class="docutils literal"><span class="pre">initPP()</span></code> method on a given pairing object in <code class="docutils literal"><span class="pre">G1</span></code>, <code class="docutils literal"><span class="pre">G2</span></code>, or <code class="docutils literal"><span class="pre">GT</span></code>. <code class="docutils literal"><span class="pre">initPP()</span></code> stores the pre-computed values for the given generator and any use of that variable in an exponentiation operation will automatically utilize the table. See how long it takes to compute 10 exponentiations with &amp; without pre-computation:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">charm.toolbox.pairinggroup</span> <span class="k">import</span> <span class="n">PairingGroup</span><span class="p">,</span><span class="n">ZR</span><span class="p">,</span><span class="n">G1</span><span class="p">,</span><span class="n">G2</span><span class="p">,</span><span class="n">GT</span><span class="p">,</span><span class="n">pair</span>

<span class="n">count</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">group</span> <span class="o">=</span> <span class="n">PairingGroup</span><span class="p">(</span><span class="s2">&quot;MNT224&quot;</span><span class="p">)</span>
<span class="n">g</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">GT</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">g</span><span class="o">.</span><span class="n">initPP</span><span class="p">(),</span> <span class="s2">&quot;failed to init pre-computation table&quot;</span>
<span class="n">h</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">GT</span><span class="p">)</span>
<span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">ZR</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

<span class="k">assert</span> <span class="n">group</span><span class="o">.</span><span class="n">InitBenchmark</span><span class="p">(),</span> <span class="s2">&quot;failed to initialize benchmark&quot;</span>
<span class="n">group</span><span class="o">.</span><span class="n">StartBenchmark</span><span class="p">([</span><span class="s2">&quot;RealTime&quot;</span><span class="p">])</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">count</span><span class="p">):</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">g</span> <span class="o">**</span> <span class="n">a</span>
<span class="n">group</span><span class="o">.</span><span class="n">EndBenchmark</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;With PP: &quot;</span><span class="p">,</span> <span class="n">group</span><span class="o">.</span><span class="n">GetBenchmark</span><span class="p">(</span><span class="s2">&quot;RealTime&quot;</span><span class="p">))</span>

<span class="k">assert</span> <span class="n">group</span><span class="o">.</span><span class="n">InitBenchmark</span><span class="p">(),</span> <span class="s2">&quot;failed to initialize benchmark&quot;</span>
<span class="n">group</span><span class="o">.</span><span class="n">StartBenchmark</span><span class="p">([</span><span class="s2">&quot;RealTime&quot;</span><span class="p">])</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">count</span><span class="p">):</span>
    <span class="n">B</span> <span class="o">=</span> <span class="n">h</span> <span class="o">**</span> <span class="n">b</span>
<span class="n">group</span><span class="o">.</span><span class="n">EndBenchmark</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Without: &quot;</span><span class="p">,</span> <span class="n">group</span><span class="o">.</span><span class="n">GetBenchmark</span><span class="p">(</span><span class="s2">&quot;RealTime&quot;</span><span class="p">))</span>
</pre></div>
</div>
<p>Feel free to send us suggestions, bug reports, issues and scheme implementation experiences within Charm at <a class="reference external" href="mailto:support&#37;&#52;&#48;charm-crypto&#46;com">support<span>&#64;</span>charm-crypto<span>&#46;</span>com</a>.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">For Cryptographers</a><ul>
<li><a class="reference internal" href="#group-abstractions">Group Abstractions</a></li>
<li><a class="reference internal" href="#implement-a-scheme">Implement a Scheme</a></li>
<li><a class="reference internal" href="#reusable-tools">Reusable Tools</a></li>
<li><a class="reference internal" href="#testing-benchmarking">Testing &amp; Benchmarking</a></li>
<li><a class="reference internal" href="#optimizations">Optimizations</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="mobile.html"
                        title="previous chapter">Android Build</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="developers.html"
                        title="next chapter">For App Developers</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/cryptographers.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="developers.html" title="For App Developers"
             >next</a> |</li>
        <li class="right" >
          <a href="mobile.html" title="Android Build"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Charm-Crypto 0.50 documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2013, Johns Hopkins University ISI.
      Last updated on Feb 20, 2018.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.6.6.
    </div>
  </body>
</html>